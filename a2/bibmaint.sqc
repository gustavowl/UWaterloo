#include <stdio.h>
#include <string.h>
#include "util.h"
#include <stdlib.h>

#define TK1 "(" //BEGIN OF COMMAND
#define TK2 ")" //END OF COMMAND
#define UPD 1
#define INS 0

EXEC SQL INCLUDE SQLCA;

typedef enum command  {
	AUTHOR = 0,
	AUTHORURL = 1,
	BOOK = 2,
	JOURNAL = 3,
	PROCEEDINGS = 4,
	ARTICLE = 5,
	INVALID = 6
} command;

//returns list with arguments
//trims a string accordingly to character split
//remember to free value returned
char** getargs(char **str, char split, int *size) {
	//char ***ret = malloc(sizeof(char**));
	*size = 0;
	char *svptr, *s;
	int i = 0;

	//Generates size
	int sz = 1;
	sz = 1;
	s = strchr(*str, split);
	while (s != NULL) {
		sz++;
		s = strchr(s+1, split);
	}
	*size = sz;
	char **ret = (char**)malloc(*size * sizeof(char*) );

    //assigns values
	s = strtok_r(*str, &split, &svptr);
	while (s != NULL) {
		//printf("\t\t%s\n", s);
		ret[i] = (char*) malloc( (strlen(s) + 1) * sizeof(char) );
		strcpy(ret[i], s);
		s = strtok_r(NULL, &split, &svptr);
		i++;
	}

	return ret;
}

void freeargs(char **args, int size) {
	int i;
	for (i = 0; i < size; i++) {
		free(args[i]);
		args[i] = NULL;
	}
	free(args);
	args = NULL;
}

void printmodifications(command cmd, char* id) {
	printf("\tDENTRO DE printmodifications\n");
}

void modifydb(command cmd, char **args, int sz_arg, char **args_aid, int sz_arg_aid, int ins_or_upd) {
	//switches, ifs
	//int aid;
	printf("\tAI DENTRO DE modifydb\n%s\n", args[0]);



   EXEC SQL BEGIN DECLARE SECTION;
	int  temp=2112;

	char pubid[11], appearsin[11];
	char name[23];
	char title[71], publisher[51];
	int aid, aorder;
	int year, volume, number, strpg, endpg;
   EXEC SQL END DECLARE SECTION;




	switch (cmd) {
		case(AUTHOR): {
			aid = atoi(args[0]);
			strcpy(name, args[1]);
			if (ins_or_upd == INS) { //INSERT
				EXEC SQL INSERT INTO author VALUES (:aid, :name, NULL);
				printf("INSERT AUTHOR #%d: %s \n", aid, name);
			}
			else { //UPDATE
				//printf("UPDATE AUTHOR #%d: %d\n", aid, temp);
				EXEC SQL SELECT 73 INTO :temp FROM author WHERE aid = :aid;
				printf("UPDATE AUTHOR #%d: %d\n", aid, temp);
			}
			break;
		}
		case (AUTHORURL): {
			//UPDATE ONLY
			printf("UPDATE AUTHORURL\n");
			break;
		}
		case (BOOK): {
			strcpy(pubid, args[0]);
			strcpy(title, args[1]);
			strcpy(publisher, args[3]);
			year = atoi(args[4]);

			if (ins_or_upd == INS) { //INSERT
				EXEC SQL INSERT INTO publication VALUES (:pubid, :title);
				for (aorder = 1; aorder <= sz_arg_aid; aorder++) {
					aid = atoi(args_aid[aorder - 1]);
					EXEC SQL INSERT INTO wrote VALUES (:aid, :pubid, :aorder);
				}
				EXEC SQL INSERT INTO book VALUES (:pubid, :publisher, :year);

				printf("INSERT BOOK \n");
			}
			else { //UPDATE
				printf("UPDATE BOOK\n");
			}
			break;
		}
		case (JOURNAL): {
			strcpy(pubid, args[0]);
			strcpy(title, args[1]);
			volume = atoi(args[2]);
			number = atoi(args[3]);
			year = atoi(args[4]);
			
			if (ins_or_upd == INS) { //INSERT
				EXEC SQL INSERT INTO publication VALUES (:pubid, :title);
				EXEC SQL INSERT INTO journal VALUES (:pubid, :volume,
					:number, :year);
					 
				printf("INSERT JOURNAL \n");
			}
			else { //UPDATE
				printf("UPDATE JOURNAL\n");
			}
			break;
		}
		case (PROCEEDINGS): {
			strcpy(pubid, args[0]);
			strcpy(title, args[1]);
			year = atoi(args[2]);

			if (ins_or_upd == INS) { //INSERT
				EXEC SQL INSERT INTO publication VALUES (:pubid, :title);
				EXEC SQL INSERT INTO proceedings VALUES (:pubid, :year);
				printf("INSERT PROCEEDINGS\n");
			}
			else { //UPDATE
				printf("UPDATE PROCEEDINGS\n");
			}
			break;
		}
		case (ARTICLE): {
			strcpy(pubid, args[0]);
			strcpy(title, args[1]);
			strcpy(appearsin, args[3]);
			strpg = atoi(args[4]);
			endpg = atoi(args[5]);

			if (ins_or_upd == INS) { //INSERT
				EXEC SQL INSERT INTO publication VALUES (:pubid, :title);
				for (aorder = 1; aorder <= sz_arg_aid; aorder++) {
					aid = atoi(args_aid[aorder - 1]);
					EXEC SQL INSERT INTO wrote VALUES (:aid, :pubid, :aorder);
				}
				EXEC SQL INSERT INTO article VALUES (:pubid, :appearsin, :strpg, :endpg);
				printf("INSERT ARTICLE \n");
			}
			else { //UPDATE
				printf("UPDATE ARTICLE\n");
			}
			break;
		}
		case(INVALID): {
			break;
		}
	}
}

int main (int argc, char *argv[]) {
	printf("argc: %d\n\n", argc);
	int i;
	for (i = 1; i < argc; i++) {
		printf("argv[%d]: %s\tsize: %d\n", i, argv[i], (int)strlen(argv[i]));
	}

	char *s, *s2, *tk;
	char *svptr, *svptr2;
	int first, size = 0, size_aid = 0;
    EXEC SQL BEGIN DECLARE SECTION;
		char db[6] = "cs348";
		char **args = NULL, **args_aid = NULL;
		char pubid[11];
		int ins_or_upd = INS, aid;
	EXEC SQL END DECLARE SECTION;
	command cmd;

   EXEC SQL WHENEVER SQLERROR  GO TO error;
   EXEC SQL CONNECT TO :db;

	s = strtok_r(argv[1], TK2, &svptr);
	printf("\n\nTrying to split\n");

	while (s != NULL) {		
		first = 1;
		s2 = s;
		tk = strtok_r(s2, TK1, &svptr2);
		while (tk != NULL) {
			if (first) {
				printf("cmd: %s\n", tk);
				if ( !strcmp(tk, "author") ) cmd = AUTHOR;
				else if ( !strcmp(tk, "authorurl") ) cmd = AUTHORURL;
				else if ( !strcmp(tk, "book") ) cmd = BOOK;
				else if ( !strcmp(tk, "journal") ) cmd = JOURNAL;
				else if ( !strcmp(tk, "proceedings") ) cmd = PROCEEDINGS;
				else if ( !strcmp(tk, "article") ) cmd = ARTICLE;
				else cmd = INVALID;
			}
			else {
				printf("\targs: %s\n", tk);
				//split
				args = getargs(&tk, '#', &size);
				for (i = 0; i < size; i++) {
					printf("\t%d: %s\n", i, args[i]);
				}
				if (cmd == BOOK || cmd == ARTICLE) {
					args_aid = getargs(&args[2], ';', &size_aid);
					for (i = 0; i < size_aid; i++) {
						printf("\t\t%d: %s\n", i, args_aid[i]);
					}
				}

				//DISCOVER IF INSERT OR UPDATE
				if (cmd == INVALID) {}
				else if (cmd == AUTHOR) {
					aid = atoi(args[0]);
					printf("AID: %d\n", aid);
					EXEC SQL SELECT 1 INTO :ins_or_upd FROM author WHERE aid = :aid;
					//case UPD value is different of 1
					if (ins_or_upd == 1) ins_or_upd = UPD;
				}
				else if (cmd == AUTHORURL) {
					ins_or_upd = UPD; //then update only
				}
				else {
					//pubid = args[0];
					strcpy(pubid, args[0]);
					EXEC SQL SELECT 1 INTO :ins_or_upd FROM publication WHERE pubid = :pubid;
					//case UPD value is different of 1
					if (ins_or_upd == 1) ins_or_upd = UPD;
				}

				modifydb(cmd, args, size, args_aid, size_aid, ins_or_upd);

				printf("INS_OR_UPD: %d\n", ins_or_upd);

				//Free arrays
				if (cmd == BOOK || cmd == ARTICLE)
					freeargs(args_aid, size_aid);
				freeargs(args, size);
			}
			tk = strtok_r(NULL, TK1, &svptr2);
			first = 0;
		}
		s = strtok_r(NULL, TK2, &svptr);
	}
	//return 0;

   EXEC SQL COMMIT;
	printmodifications(cmd, args[0]);
   EXEC SQL CONNECT reset;

   exit(0);

error:
   check_error("My error",&sqlca);
   EXEC SQL WHENEVER SQLERROR CONTINUE;

   EXEC SQL ROLLBACK;
   EXEC SQL CONNECT reset;
   exit(1);
}
