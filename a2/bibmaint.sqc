#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define TK1 "(" //BEGIN OF COMMAND
#define TK2 ")" //END OF COMMAND
#define UPD 1
#define INS 0

typedef enum command  {
	AUTHOR = 0,
	AUTHORURL = 1,
	BOOK = 2,
	JOURNAL = 3,
	PROCEEDINGS = 4,
	ARTICLE = 5,
	INVALID = 6
} command;

//returns list with arguments
//trims a string accordingly to character split
//remember to free value returned
char** getargs(char **str, char split, int *size) {
	//char ***ret = malloc(sizeof(char**));
	*size = 0;
	char *svptr, *s;
	int i = 0;

	//Generates size
	int sz = 1;
	sz = 1;
	s = strchr(*str, split);
	while (s != NULL) {
		sz++;
		s = strchr(s+1, split);
	}
	*size = sz;
	char **ret = (char**)malloc(*size * sizeof(char*) );

    //assigns values
	s = strtok_r(*str, &split, &svptr);
	while (s != NULL) {
		//printf("\t\t%s\n", s);
		ret[i] = (char*) malloc( (strlen(s) + 1) * sizeof(char) );
		strcpy(ret[i], s);
		s = strtok_r(NULL, &split, &svptr);
		i++;
	}

	return ret;
}

void freeargs(char **args, int size) {
	for (int i = 0; i < size; i++) {
		free(args[i]);
		args[i] = NULL;
	}
	free(args);
	args = NULL;
}

void printmodifications(command cmd, char* id) {
	printf("\tDENTRO DE printmodifications\n");
}

void modifydb(command cmd, char **args, int sz_arg, char **args_aid, int sz_arg_aid, int ins_or_upd) {
	//switches, ifs
	printf("\tAI DENTRO DE modifydb\n%s\n", args[0]);
}

int main (int argc, char *argv[]) {
	printf("argc: %d\n\n", argc);
	for (int i = 1; i < argc; i++) {
		printf("argv[%d]: %s\tsize: %d\n", i, argv[i], strlen(argv[i]));
	}

	char *s, *s2, *tk, **args = NULL, **args_aid = NULL;
	char *svptr, *svptr2;
	int first, size = 0, size_aid = 0, ins_or_upd = INS;
	command cmd;

	s = strtok_r(argv[1], TK2, &svptr);
	printf("\n\nTrying to split\n");

	while (s != NULL) {		
		first = 1;
		s2 = s;
		tk = strtok_r(s2, TK1, &svptr2);
		while (tk != NULL) {
			if (first) {
				printf("cmd: %s\n", tk);
				if ( !strcmp(tk, "author") ) cmd = AUTHOR;
				else if ( !strcmp(tk, "authorurl") ) cmd = AUTHORURL;
				else if ( !strcmp(tk, "book") ) cmd = BOOK;
				else if ( !strcmp(tk, "journal") ) cmd = JOURNAL;
				else if ( !strcmp(tk, "proceedings") ) cmd = PROCEEDINGS;
				else if ( !strcmp(tk, "article") ) cmd = ARTICLE;
				else cmd = INVALID;
			}
			else {
				printf("\targs: %s\n", tk);
				//split
				args = getargs(&tk, '#', &size);
				for (int i = 0; i < size; i++) {
					printf("\t%d: %s\n", i, args[i]);
				}
				if (cmd == BOOK || cmd == ARTICLE) {
					args_aid = getargs(&args[2], ';', &size_aid);
					for (int i = 0; i < size_aid; i++) {
						printf("\t\t%d: %s\n", i, args_aid[i]);
					}
				}

				//DISCOVER IF INSERT OR UPDATE
				if (cmd == INVALID) {}
				else if (cmd == AUTHOR) {
					//EXEC SQL SELECT 1 INTO :ins_or_upd FROM author WHERE aid = :args[0];
				}
				else if (cmd == AUTHORURL) {
					ins_or_upd = UPD; //then update only
				}
				else {
					//EXEC SQL SELECT 1 INTO :ins_or_upd FROM publication WHERE pubid = :args[0];
				}

				modifydb(cmd, args, size, args_aid, size_aid, ins_or_upd);
				printmodifications(cmd, args[0]);

				//Free arrays
				if (cmd == BOOK || cmd == ARTICLE)
					freeargs(args_aid, size_aid);
				freeargs(args, size);
			}
			tk = strtok_r(NULL, TK1, &svptr2);
			first = 0;
		}
		s = strtok_r(NULL, TK2, &svptr);
	}
	return 0;
}